<!-- base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Home{% endblock %} | CCDR Explorer</title>
    
    <link href="{{ url_for('static', path='css/styles.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', path='css/extras.css') }}" rel="stylesheet">

    <link rel="apple-touch-icon" sizes="152x152" href="{{ url_for('static', path='apple-touch-icon.png') }}">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', path='favicon-32x32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', path='favicon-16x16.png') }}">
    <link rel="manifest" href="{{ url_for('static', path='site.webmanifest') }}">
    <link rel="mask-icon" href="{{ url_for('static', path='safari-pinned-tab.svg') }}" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
</head>
<body class="h-100 min-vh-100 d-flex flex-column">    
    <header>
        <!-- Common header content -->
        {% include 'base/partials/header.html' %}
    </header>
    
    <main class="d-flex flex-column flex-grow-1">
        {% block content %}
        <!-- Page-specific content goes here -->
        {% endblock %}
    </main>
    
    <footer>
        <!-- Common footer content -->
        {% include 'base/partials/footer.html' %}
    </footer>
    
    <!-- Common scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- HTMX for ajax functionality -->
    <script src="{{ url_for('static', path='htmx.min.js') }}"></script>
    <!-- SSE extensions for server-sent events -->
    <script src="{{ url_for('static', path='sse.js') }}"></script>
    <!-- Markdown Rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script>
      // A global map to hold the growing markdown string per target container node
      window._streamingMarkdown = new WeakMap();

      function handleSSETextDelta(evt) {
        // Check if this event is for a 'textDelta' message fired by sse.js
        const originalSSEEvent = evt.detail; // The original SSE MessageEvent IS the detail
        if (!originalSSEEvent || originalSSEEvent.type !== 'textDelta') {
            return; // Not the event we're looking for
        }

        // Prevent the default HTMX swap for this specific message
        // sse.js triggers this *before* calling api.swap()
        evt.preventDefault();

        // The data contains the OOB swap HTML: <span hx-swap-oob="beforeend:#step-...">CHUNK</span>
        const oobHTML = originalSSEEvent.data;

        // Use DOMParser to safely extract the target selector and the markdown chunk
        const parser = new DOMParser();
        const doc = parser.parseFromString(oobHTML, 'text/html');
        const oobElement = doc.body.firstChild;

        if (!oobElement || !oobElement.getAttribute || oobElement.nodeType !== Node.ELEMENT_NODE) {
            console.error("Could not parse OOB element from SSE data:", oobHTML);
            return;
        }

        const swapOobAttr = oobElement.getAttribute('hx-swap-oob');
        const markdownChunk = oobElement.textContent || '';

        if (!swapOobAttr) {
             // Might be a non-OOB textDelta, handle differently or ignore?
             // For now, let's assume textDelta is always OOB for steps.
            console.warn("textDelta message did not contain hx-swap-oob:", oobHTML);
            return;
        }
         if (!markdownChunk) {
            // Empty chunk, nothing to render
            return;
        }

        // Extract the target selector (e.g., "beforeend:#step-...") -> "#step-..."
        let targetSelector = swapOobAttr;
        const colonIndex = swapOobAttr.indexOf(':');
        if (colonIndex !== -1) {
            targetSelector = swapOobAttr.substring(colonIndex + 1);
        }

        // Find the actual target element where content should be rendered
        const targetElement = document.querySelector(targetSelector);
        if (!targetElement) {
            // Target might not exist *yet* if messageCreated hasn't been processed.
            // This can happen due to async nature. We might need to queue or retry.
            // For now, log a warning. A robust solution might wait briefly.
            console.warn("Target element for OOB swap not found yet:", targetSelector);
            return;
        }

        // Use a WeakMap keyed by the *actual target* element
        if (!window._streamingMarkdown) {
            window._streamingMarkdown = new WeakMap(); // Should be initialized above
        }

        // 1) Accumulate markdown for the specific target
        const prev = window._streamingMarkdown.get(targetElement) || '';
        const updatedMarkdown = prev + markdownChunk;
        window._streamingMarkdown.set(targetElement, updatedMarkdown);

        // 2) Re-render -> sanitize -> swap into the target
        // Ensure marked and DOMPurify are loaded and available
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
            console.error("marked.js or DOMPurify not loaded.");
            targetElement.textContent += markdownChunk; // Fallback to raw text
            return;
        }

        try {
            // Use marked.parse() for incremental updates.
            const rawHtml = marked.parse(updatedMarkdown);
            // Configure DOMPurify to allow common formatting tags, lists, code blocks, etc.
            // Adjust based on the markdown features you expect/want to support.
            const sanitizedHtml = DOMPurify.sanitize(rawHtml, {
                USE_PROFILES: { html: true } // Allows standard HTML elements
             });
            targetElement.innerHTML = sanitizedHtml;

            // 3) Optional: Auto-scroll the main messages container
            const messagesContainer = document.getElementById('messages'); // From index.html
            if (messagesContainer) {
                // Scroll only if the user isn't intentionally scrolled up
                const isScrolledToBottom = messagesContainer.scrollHeight - messagesContainer.clientHeight <= messagesContainer.scrollTop + 1; // +1 for tolerance
                if(isScrolledToBottom) {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            }
        } catch (e) {
            console.error("Error processing markdown:", e);
            // Fallback on error: append raw chunk to existing text content
             targetElement.textContent = (targetElement.textContent || '') + markdownChunk;
        }
      }
    </script>
</body>
</html>
